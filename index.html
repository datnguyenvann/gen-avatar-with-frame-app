<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Gh√©p khung avatar</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    .header h1 {
      margin: 0;
      font-size: 2.5rem;
      font-weight: 300;
    }
    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      padding: 30px;
    }
    .left-panel {
      display: flex;
      flex-direction: column;
      gap: 25px;
    }
    .right-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    .section {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 25px;
      border: 1px solid #e9ecef;
    }
    .section h3 {
      margin: 0 0 20px 0;
      font-size: 1.3rem;
      color: #495057;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    canvas { 
      border: 3px solid #dee2e6; 
      border-radius: 15px;
      cursor: grab; 
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    }
    canvas:active { cursor: grabbing; }
    .frame-gallery { 
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-top: 15px;
    }
    .frame-option { 
      width: 80px; 
      height: 80px; 
      border: 3px solid #dee2e6; 
      cursor: pointer; 
      border-radius: 12px;
      transition: all 0.3s ease;
      justify-self: center;
    }
    .frame-option:hover { 
      border-color: #667eea; 
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }
    .frame-option.selected { 
      border-color: #667eea; 
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      transform: scale(1.05);
    }
    .upload-section {
      text-align: center;
    }
    .file-input-wrapper {
      position: relative;
      display: inline-block;
      margin-top: 10px;
    }
    .file-input {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }
    .file-button {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 12px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .file-button:hover {
      transform: translateY(-2px);
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .control-row {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #dee2e6;
      outline: none;
      appearance: none;
    }
    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
    }
    .value-display {
      min-width: 60px;
      text-align: center;
      font-weight: 600;
      color: #667eea;
    }
    .button-group {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 25px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .btn-secondary {
      background: linear-gradient(135deg, #ff6b6b 0%, #ff8e53 100%);
      color: white;
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    .help-text {
      background: #e3f2fd;
      color: #1976d2;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      font-size: 14px;
      border-left: 4px solid #2196f3;
    }
    @media (max-width: 768px) {
      .main-content {
        grid-template-columns: 1fr;
      }
      .frame-gallery {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé® Gh√©p khung avatar cho Zalo</h1>
    </div>
    
    <div class="main-content">
      <!-- Left Panel - Controls -->
      <div class="left-panel">
        <!-- Upload Avatar Section -->
        <div class="section upload-section">
          <h3>üì∏ Ch·ªçn ·∫£nh avatar</h3>
          <div class="file-input-wrapper">
            <input type="file" id="upload" class="file-input" accept="image/*">
            <button class="file-button">
              <span>üìÅ</span>
              <span>T·∫£i ·∫£nh l√™n</span>
            </button>
          </div>
        </div>

        <!-- Fixed Frame Info Section -->
        <div class="section">
          <h3>üñºÔ∏è Khung c·ªë ƒë·ªãnh</h3>
          <div style="text-align: center; color: #666; margin-bottom: 15px;">
            <p>S·ª≠ d·ª•ng file khung local: <code>frame.svg</code></p>
            <small>ƒê·∫∑t file khung trong c√πng th∆∞ m·ª•c v·ªõi index.html</small>
            <small style="display: block; margin-top: 8px; color: #28a745;">‚úÖ File m·∫´u ƒë√£ ƒë∆∞·ª£c t·∫°o s·∫µn</small>
          </div>
          <div style="text-align: center;">
            <button onclick="toggleFrame()" class="btn btn-secondary" id="frameToggle">
              <span>üëÅÔ∏è</span>
              <span>T·∫Øt khung</span>
            </button>
          </div>
        </div>

        <!-- Frame Gallery Section -->
        <!-- <div class="section">
          <h3>üñºÔ∏è Ch·ªçn khung c√≥ s·∫µn</h3>
          <div class="frame-gallery">
            <div class="frame-option" data-frame="circular" style="background: linear-gradient(45deg, #ff6b6b, #ff8e53); border-radius: 50%;" title="Khung tr√≤n"></div>
            <div class="frame-option" data-frame="heart" style="background: linear-gradient(45deg, #ff6b9d, #c44569); clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);" title="Khung tr√°i tim"></div>
            <div class="frame-option" data-frame="star" style="background: linear-gradient(45deg, #ffd700, #ff8c00); clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);" title="Khung ng√¥i sao"></div>
            <div class="frame-option" data-frame="diamond" style="background: linear-gradient(45deg, #00d2ff, #3a7bd5); clip-path: polygon(50% 0%, 80% 50%, 50% 100%, 20% 50%);" title="Khung kim c∆∞∆°ng"></div>
            <div class="frame-option" data-frame="hexagon" style="background: linear-gradient(45deg, #a8edea, #fed6e3); clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);" title="Khung l·ª•c gi√°c"></div>
            <div class="frame-option" data-frame="rounded" style="background: linear-gradient(45deg, #667eea, #764ba2); border-radius: 20px;" title="Khung bo g√≥c"></div>
          </div>
        </div> -->

        <!-- Upload Custom Frame Section -->
        <!-- <div class="section upload-section">
          <h3>üìÅ Khung t√πy ch·ªânh</h3>
          <div class="file-input-wrapper">
            <input type="file" id="frameUpload" class="file-input" accept="image/*">
            <button class="file-button">
              <span>üñºÔ∏è</span>
              <span>T·∫£i khung l√™n</span>
            </button>
          </div>
        </div> -->

        <!-- Controls Section -->
        <div class="section">
          <h3>üéõÔ∏è ƒêi·ªÅu ch·ªânh ·∫£nh</h3>
          <div class="controls">
            <div class="control-group">
              <label>üîç K√≠ch th∆∞·ªõc</label>
              <div class="control-row">
                <input type="range" id="scaleSlider" class="slider" min="0.5" max="3" step="0.1" value="1">
                <span id="scaleValue" class="value-display">100%</span>
              </div>
            </div>
            
            <div class="control-group">
              <label>‚ÜîÔ∏è Xoay</label>
              <div class="control-row">
                <input type="range" id="rotationSlider" class="slider" min="-180" max="180" step="5" value="0">
                <span id="rotationValue" class="value-display">0¬∞</span>
              </div>
            </div>
            
            <button onclick="resetTransform()" class="btn btn-secondary">
              <span>üîÑ</span>
              <span>Reset</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Right Panel - Canvas and Actions -->
      <div class="right-panel">
        <canvas id="canvas" width="500" height="500"></canvas>
        
        <div class="help-text">
          üí° K√©o ·∫£nh ƒë·ªÉ di chuy·ªÉn, d√πng thanh tr∆∞·ª£t ƒë·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc v√† xoay
        </div>
        
        <div class="button-group">
          <button onclick="downloadImage()" class="btn btn-primary">
            <span>‚¨áÔ∏è</span>
            <span>T·∫£i ·∫£nh k·∫øt qu·∫£</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let userImg = new Image();
    let frameImg = new Image();
    let userImgLoaded = false;
    let frameImgLoaded = false;

    // Transform properties
    let imgScale = 1;
    let imgRotation = 0;
    let imgX = 0;
    let imgY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Khung c·ªë ƒë·ªãnh - s·ª≠ d·ª•ng file local
    // ƒê·∫∑t file khung trong c√πng th∆∞ m·ª•c v·ªõi index.html
    const FIXED_FRAME_URL = "./frame.svg"; // Thay b·∫±ng t√™n file khung c·ªßa b·∫°n (c√≥ th·ªÉ l√† .png, .jpg, .svg)
    
    // T·∫£i khung c·ªë ƒë·ªãnh ngay khi trang load
    frameImg.src = FIXED_FRAME_URL;
    // Kh√¥ng c·∫ßn crossOrigin cho file local

    // Khung PNG trong su·ªët (thay link ·∫£nh PNG c·ªßa b·∫°n)
    // frameImg.src = "https://i.ibb.co/5RMRM2P/sample-frame.png";
    // frameImg.src = "https://drive.google.com/file/d/1oQHmE3C98oYSJhxtByJXoZyxE1SyIap7/view?usp=sharing"; 

    // Bi·∫øn ƒë·ªÉ ki·ªÉm so√°t hi·ªÉn th·ªã khung
    let showFrame = true;

    // H√†m toggle khung
    function toggleFrame() {
      showFrame = !showFrame;
      const toggleBtn = document.getElementById('frameToggle');
      if (showFrame) {
        toggleBtn.innerHTML = '<span>üëÅÔ∏è</span><span>T·∫Øt khung</span>';
        frameImgLoaded = true;
      } else {
        toggleBtn.innerHTML = '<span>üö´</span><span>B·∫≠t khung</span>';
        frameImgLoaded = false;
      }
      draw();
    } 

    // X·ª≠ l√Ω click v√†o khung c√≥ s·∫µn
    document.querySelectorAll('.frame-option').forEach(frameOption => {
      frameOption.addEventListener('click', function() {
        console.log('Frame clicked:', this.dataset.frame);
        
        // B·ªè selection c≈©
        document.querySelectorAll('.frame-option').forEach(opt => opt.classList.remove('selected'));
        // Th√™m selection m·ªõi
        this.classList.add('selected');
        
        // √Åp d·ª•ng frame style
        const frameType = this.dataset.frame;
        frameImgLoaded = false; // Reset frame image
        applyFrameStyle(frameType);
      });
    });

    function applyFrameStyle(frameType) {
      // √Åp d·ª•ng frame style v√† v·∫Ω l·∫°i
      selectedFrame = frameType;
      draw();
    }

    let selectedFrame = null; 

    // Canvas mouse events for dragging
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('mouseleave', endDrag);

    // Slider events
    document.getElementById('scaleSlider').addEventListener('input', function(e) {
      imgScale = parseFloat(e.target.value);
      document.getElementById('scaleValue').textContent = Math.round(imgScale * 100) + '%';
      draw();
    });

    document.getElementById('rotationSlider').addEventListener('input', function(e) {
      imgRotation = parseFloat(e.target.value) * Math.PI / 180;
      document.getElementById('rotationValue').textContent = e.target.value + '¬∞';
      draw();
    });

    function resetTransform() {
      imgScale = 1;
      imgRotation = 0;
      imgX = 0;
      imgY = 0;
      document.getElementById('scaleSlider').value = 1;
      document.getElementById('rotationSlider').value = 0;
      document.getElementById('scaleValue').textContent = '100%';
      document.getElementById('rotationValue').textContent = '0¬∞';
      draw();
    }

    function startDrag(e) {
      if (!userImgLoaded) return;
      isDragging = true;
      const rect = canvas.getBoundingClientRect();
      lastMouseX = e.clientX - rect.left;
      lastMouseY = e.clientY - rect.top;
    }

    function drag(e) {
      if (!isDragging || !userImgLoaded) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      imgX += mouseX - lastMouseX;
      imgY += mouseY - lastMouseY;
      
      lastMouseX = mouseX;
      lastMouseY = mouseY;
      
      draw();
    }

    function endDrag() {
      isDragging = false;
    } 

    document.getElementById("upload").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        userImg.onload = function() {
          userImgLoaded = true;
          // Reset transform khi load ·∫£nh m·ªõi
          resetTransform();
        };
        userImg.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    document.getElementById("frameUpload").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      // B·ªè selection khung c√≥ s·∫µn khi upload khung t√πy ch·ªânh
      document.querySelectorAll('.frame-option').forEach(opt => opt.classList.remove('selected'));
      selectedFrame = null; // Reset CSS frame
      
      const reader = new FileReader();
      reader.onload = function(evt) {
        frameImg.onload = function() {
          frameImgLoaded = true;
          draw();
        };
        frameImg.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Thi·∫øt l·∫≠p s·ª± ki·ªán onload cho frame m·∫∑c ƒë·ªãnh
    frameImg.onload = function() {
      frameImgLoaded = true;
      console.log('Fixed frame loaded successfully');
      draw();
    };
    
    frameImg.onerror = function() {
      console.error('Failed to load local frame:', FIXED_FRAME_URL);
      console.log('H√£y ƒë·∫£m b·∫£o file khung ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t trong c√πng th∆∞ m·ª•c v·ªõi index.html');
      frameImgLoaded = false;
      // Th·ª≠ load frame backup n·∫øu frame ch√≠nh b·ªã l·ªói
      frameImg.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='500' height='500'%3E%3Ccircle cx='250' cy='250' r='240' fill='none' stroke='%23ff6b6b' stroke-width='20'/%3E%3C/svg%3E";
    };

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // V·∫Ω ·∫£nh avatar tr∆∞·ªõc (n·ªÅn)
      if (userImgLoaded && userImg.complete) {
        if (selectedFrame) {
          // √Åp d·ª•ng mask cho avatar theo frame ƒë∆∞·ª£c ch·ªçn
          ctx.save();
          applyFrameMask(selectedFrame);
          drawTransformedImage();
          ctx.restore();
          
          // V·∫Ω border frame
          drawFrameBorder(selectedFrame);
        } else {
          drawTransformedImage();
        }
      }
      
      // V·∫Ω khung t·ª´ file (n·∫øu c√≥ v√† ƒëang b·∫≠t)
      if (frameImgLoaded && frameImg.complete && showFrame) {
        ctx.drawImage(frameImg, 0, 0, canvas.width, canvas.height);
      }
    }

    function drawTransformedImage() {
      ctx.save();
      
      // Di chuy·ªÉn ƒë·∫øn center + offset
      const centerX = canvas.width / 2 + imgX;
      const centerY = canvas.height / 2 + imgY;
      ctx.translate(centerX, centerY);
      
      // Xoay
      ctx.rotate(imgRotation);
      
      // Scale
      ctx.scale(imgScale, imgScale);
      
      // V·∫Ω ·∫£nh v·ªõi center l√†m anchor point
      const imgWidth = canvas.width;
      const imgHeight = canvas.height;
      ctx.drawImage(userImg, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
      
      ctx.restore();
    }

    function applyFrameMask(frameType) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) / 2 - 20;
      
      ctx.beginPath();
      
      switch(frameType) {
        case 'circular':
          ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
          break;
        case 'heart':
          drawHeartPath(centerX, centerY, radius * 0.8);
          break;
        case 'star':
          drawStarPath(centerX, centerY, radius * 0.8, 5);
          break;
        case 'diamond':
          drawDiamondPath(centerX, centerY, radius * 0.8);
          break;
        case 'hexagon':
          drawHexagonPath(centerX, centerY, radius * 0.8);
          break;
        case 'rounded':
          ctx.roundRect(centerX - radius, centerY - radius, radius * 2, radius * 2, 40);
          break;
        default:
          ctx.rect(0, 0, canvas.width, canvas.height);
      }
      
      ctx.clip();
    }

    function drawFrameBorder(frameType) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) / 2 - 20;
      
      ctx.strokeStyle = getFrameColor(frameType);
      ctx.lineWidth = 8;
      ctx.beginPath();
      
      switch(frameType) {
        case 'circular':
          ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
          break;
        case 'heart':
          drawHeartPath(centerX, centerY, radius * 0.8);
          break;
        case 'star':
          drawStarPath(centerX, centerY, radius * 0.8, 5);
          break;
        case 'diamond':
          drawDiamondPath(centerX, centerY, radius * 0.8);
          break;
        case 'hexagon':
          drawHexagonPath(centerX, centerY, radius * 0.8);
          break;
        case 'rounded':
          ctx.roundRect(centerX - radius, centerY - radius, radius * 2, radius * 2, 40);
          break;
      }
      
      ctx.stroke();
    }

    function getFrameColor(frameType) {
      const colors = {
        'circular': '#ff6b6b',
        'heart': '#ff6b9d',
        'star': '#ffd700',
        'diamond': '#00d2ff',
        'hexagon': '#a8edea',
        'rounded': '#667eea'
      };
      return colors[frameType] || '#333';
    }

    function drawHeartPath(x, y, size) {
      const heartPath = new Path2D();
      heartPath.moveTo(x, y + size * 0.3);
      heartPath.bezierCurveTo(x, y, x - size * 0.5, y, x - size * 0.5, y + size * 0.3);
      heartPath.bezierCurveTo(x - size * 0.5, y + size * 0.7, x, y + size * 1.1, x, y + size * 1.1);
      heartPath.bezierCurveTo(x, y + size * 1.1, x + size * 0.5, y + size * 0.7, x + size * 0.5, y + size * 0.3);
      heartPath.bezierCurveTo(x + size * 0.5, y, x, y, x, y + size * 0.3);
      ctx.arc = heartPath;
      return ctx.fill(heartPath) || ctx.stroke(heartPath);
    }

    function drawStarPath(x, y, radius, points) {
      const angle = Math.PI / points;
      ctx.moveTo(x + Math.cos(0) * radius, y + Math.sin(0) * radius);
      for (let i = 1; i <= points * 2; i++) {
        const r = i % 2 === 0 ? radius : radius * 0.5;
        const currentAngle = angle * i;
        ctx.lineTo(x + Math.cos(currentAngle) * r, y + Math.sin(currentAngle) * r);
      }
      ctx.closePath();
    }

    function drawDiamondPath(x, y, size) {
      ctx.moveTo(x, y - size);
      ctx.lineTo(x + size, y);
      ctx.lineTo(x, y + size);
      ctx.lineTo(x - size, y);
      ctx.closePath();
    }

    function drawHexagonPath(x, y, radius) {
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const xPos = x + Math.cos(angle) * radius;
        const yPos = y + Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(xPos, yPos);
        else ctx.lineTo(xPos, yPos);
      }
      ctx.closePath();
    }

    function downloadImage() {
      const link = document.createElement("a");
      link.download = "avatar_zalo.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    }
  </script>
</body>
</html>
